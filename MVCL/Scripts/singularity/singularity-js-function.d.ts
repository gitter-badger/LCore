/// <reference path="singularity-core.d.ts" />
interface Function {
    fn_try?: <T>(logFailure?: boolean) => (...items: any[]) => T;
    fn_catch(catchFunction?: (ex: any) => void, logFailure?: boolean): Function;
    fn_catch<T>(catchFunction?: (ex: any) => void, logFailure?: boolean): (...items: any[]) => T;
    fn_log?: <T>(logAttempt?: boolean, logSuccess?: boolean, logFailure?: boolean) => (...items: any[]) => T;
    fn_time?: <T>() => (...items: any[]) => T;
    fn_count?: <T>(logFailure?: boolean) => (...items: any[]) => T;
    fn_trace?: <T>() => (...items: any[]) => T;
    fn_cache<T>(uniqueCacheID: string, expiresAfter?: Date): (var1: T) => void;
    fn_cache<T, U>(uniqueCacheID: string, expiresAfter?: Date): (var1: T) => U;
    fn_cache<T, T2, U>(uniqueCacheID: string, expiresAfter?: Date): (var1: T, var2?: T2) => U;
    fn_cache<T>(uniqueCacheID: string, expiresAfter?: Date): (...items: any[]) => T;
    fn_if?: (ifFunc: (...items: any[]) => boolean) => (...items: any[]) => any;
    fn_unless?: <T>(unlessFunc: (...items: any[]) => boolean) => (...items: any[]) => T;
    fn_then?: <T>(thenFunc: (...items: any[]) => any) => (...items: any[]) => T;
    fn_repeat<T>(times: number): (...items: any[]) => T;
    fn_repeat<T>(list: any[]): (...items: any[]) => T;
    fn_repeat<T>(repeat_fn: (...items: any[]) => T): (...items: any[]) => T;
    fn_while?: <T>(whileFunc: (...items: any[]) => boolean) => (...items: any[]) => T;
    fn_until?: <T>(untilFunc: (...items: any[]) => boolean) => (...items: any[]) => T;
    fn_repeatEvery?: <T>(periodMS: number) => (...items: any[]) => T;
    fn_retry?: <T>(times: number) => (...items: any[]) => T;
    fn_recurring?: (intervalMS: number, breakCondition?: number | ((...items: any[]) => boolean)) => ((...items: any[]) => void);
    fn_defer?: <T>(callback?: (...items: any[]) => void) => () => T;
    fn_delay?: <T>(delayMS: number) => (...items: any[]) => T;
    fn_async?: <T>(callback?: (...items: any[]) => void) => (...items: any[]) => T;
    fn_wrap?: <T>(wrapper: (fn: (...items: any[]) => T, ...items: any[]) => T) => (...items: any[]) => T;
    fn_onExecute?: <T>(eventHandler: (...items: any[]) => void) => (...items: any[]) => T;
    fn_onExecuted?: <T>(eventHandler: (...items: any[]) => void) => (...items: any[]) => T;
    fn_or?: (orFunc: (...items: any[]) => boolean) => (...items: any[]) => boolean;
    fn_and?: (orFunc: (...items: any[]) => boolean) => (...items: any[]) => boolean;
    fn_not(): () => boolean;
    fn_not(): Function;
}
declare var singFunction: SingularityModule;
declare function FunctionTry(): Function;
declare function FunctionCatch(catchFunction: Function, logFailure?: boolean): Function;
declare function FunctionLog(logAttempt?: boolean, logSuccess?: boolean, logFailure?: boolean): () => any;
declare function FunctionCount(logFailure?: boolean): () => any;
declare function FunctionCache(uniqueCacheID: string, expiresAfter?: number): (...items: any[]) => any;
declare function FunctionOR(orFunc: (...items: any[]) => boolean): (...items: any[]) => boolean;
declare function FunctionIf<T>(ifFunc: (...items: any[]) => boolean): (...items: any[]) => any;
declare function FunctionUnless(ifFunc: (...items: any[]) => boolean): (...items: any[]) => any;
declare function FunctionThen(thenFunc: Function): Function;
declare function FunctionRepeat(repeatOver: number | any[] | ((...items: any[]) => boolean)): (...items: any[]) => any;
declare function FunctionWhile(condition: ((...items: any[]) => boolean)): (...items: any[]) => any;
declare function FunctionRetry(times?: number): (...items: any[]) => any;
declare function FunctionTime(): (...items: any[]) => any;
declare function FunctionDefer(callback?: Function): (...items: any[]) => void;
declare function FunctionDelay(delayMS: number, callback?: Function): (...items: any[]) => void;
declare function FunctionBefore(triggerFunc?: Function): (...items: any[]) => any;
declare function FunctionAfter(triggerFunc?: Function): (...items: any[]) => any;
declare function FunctionWrap(triggerFunc?: Function): (...items: any[]) => any;
declare function FunctionTrace(traceStr?: string): (...items: any[]) => any;
declare function FunctionRecurring(intervalMS: number, breakCondition?: number | ((...items: any[]) => boolean)): (...items: any[]) => void;
declare function ArrayExecuteAll(...items: Function[]): any[];
declare function FunctionNot(): Function;
